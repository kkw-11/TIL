# Linux 
    * 인델 80386 이상의 프로세서를 사용하는 PC에서 운영되는 유닉스 운영체제의 공개 버전
## Linux 특징
* 멀티태스킹, 멀티유저
    * 멀티태스킹 시스템으로서, 한 시스템 상에서 여러 사용자가 많은 프로그램을 동시에 사용할 수 있음
* GNU 소프트웨어 제공
    * GNU C, C++컴파일러, gawk, groff 등과 같은 공개 소프트웨어를 제공함
* X Window
    * 한화면에 동시에 여러개의 윈도우로부터 다중 로그인할 수 있으며, 여러 애플리케이션을 동시에 작동시킬 수 있음
* TCP/IP 네트워킹
* 오픈소스
    * 무료이고, 시스템의 특성에 맞게 소스를 변경할 수 있음
* 가상메모리와 공유 라이브러리
    * 하드드라이브를 가상 메모리로서 사용할 수 있음
        * 실제의 RAM 용량을 확장시킴
        * 공유 라이브러리를 구현함
        * 각각의 응용 프로그램이 공통되는 루틴을 별도로 저장하지 않아서 시스템의 많은 하드 공간을 줄여줌
* 저사양에서도 강력한 성능을 발휘함
* 프로그램의 호환성이 떨어짐

## 프로세스 관리
* 프로세스의 개념
    * 프로세스
        * 다중 프로그래밍 처리의 기본 단위
        * 운영체제 내에서 실행 중인 연산과정, 프로그램 상태의 집합

    * 운영체제는 새로운 작업(job)이 들어오면 그 프로그램과 데이터에 주기억장치의 공간을 할당함으로써 프로세스를 생성함
    * 프로그램의 실행이 종료되면 프로세스는 소멸됨
    * 작업(job)과 프로세스는 차이점이 있음
        *하나의 작업은 그 처리과정에서 여러 개의 독립적인 프로세스가 형성되기 때문임

    * 프로세스 제어 블록(process control block)
        * 프로세스에 과한 정보를 보관하고 있는 기억 장소
        * 프로세스의 상태
    * 프로세스에 관련된 제어프로그램의 실행에 따라 변화하며, 프로세스의 이름, 현재상태, 우선순위, 주기억장소의 영역, 배당된 자원 등에 대한 정보를 포함함
    * 프로세스가 수행됨에 따라 발생하는 지역변수(local variable)나 프로세스가 인터럽트 될 때 보존되어야 할 레스터의 내용들을 포함함
    * 프로세스 이미지
        * 프로세스 제어블록 + 프로그램 코드 및 데이터 + 스택

    ## 프로세스의 상태
        * 실행(running) - 현재 프로세스가 실행되고 있는 상태
        * 대기(waiting) - 입,출력 프로세스의 작업이 완료되기를 기다리는 상태
        * 준비(ready) - 프로세스의 배당을 기다리는 상태
    
    ![image](https://user-images.githubusercontent.com/76929823/120909084-36bd9200-c6ac-11eb-912a-ad8fea22b360.png)

* 시스템 병행성(system concurrency)
    * 여러 프로세스가 서로 아무런 영향을 주지 않고 병행적으로 동시 수행되는 방법
    * 시분할 시스템 및 다중 프로그래밍 시스템에서의 우선순위 처리에 중요한 개념

    * 상호 배제(mutual exclusion)
        * 한 프로세스가 공용변수를 변경하고 있을 때는 다른 프로세스가 이들 고용 변수를 사용하면 안됨
    * 임계 영역(ciriticaal region)
        * 프로그램에서 공용 변수를 접근(access)하는 부분
        * 임계 영역 내에서는 프로세스들이 병행적으로 수행되지 않도록 하는 기법이 제공되어 상호 배제가 보장되도록 함

* 프로세스의 동기화
    * 프로세스 교신(process communication) 
        * 프로세스 간의 상호 작용

    * 프로세스 동기화(process synchronization) 
        * 프로세스의 실행을 시간에 따라 순서대로 처리하는 것
        * 동기화 문제를 해결하는 일발적인 방법이 세마포어(semaphore)

    * 세마포어(semaphore)
        * 초기상태의 변수값은 자원의 수와 같고, 대기열은 비어 있음
        * 공유자원에 대한 접근을 제어하기 위해 사용되는 신호
        
        ![image](https://user-images.githubusercontent.com/76929823/120909265-4fc74280-c6ae-11eb-979a-8e88e2b4089e.png)
        
        * 변수의 값이 음수일 경우 : 대기 중인 프로세스의 수를 나타냄
        * 변수의 값이 양수일 경우 : 사용 가능한 자원의 수를 나타냄
        * 변수의 값이 0일 경우 : 자원을 사용할 수 없음
        * 이 자원에 접근할 수 있는 프로세스의 숫자가 0이라는 뜻

        * 차단을 원하는 자원에 대해서 세마포어를 생성하면 해당자원을 가리키는 사케포어 값이 할당 됨
        * 세마포어 값에는 현재 세마포어를 적용하고 있는 자원에 접근할 수 있는 프로세스의 숫자를 나타냄
        * 접근제어를 해야 하는 자원에 접근하기 전에 세마포어 값을 검사해서 값이 0이면 자원을 사용할 수 있을 때까지 기다리고, 0보다 더 크면 자원에 접근해서 사메포어 값을 1 감소시킴
            * 예1 세마포어 값이 1인 경우
                * 자원에 접근하기 전에 세마포어 값을 검사해서 값이 양수이므로 자원에 접근함-> 세마포어 값을 1 감소시켜서 0을 만듦으로써, 다른 프로세스가 자원에 접근할 수 없도록 함 -> 자원의 사용이 끝나면 세마포어 값을 다시 1 증가시켜서 다른 프로세스가 자원을 사용할 수 있도록 만들어줌
            * 예2 세마포어 값이 0 인 경우
                - 세마포어 값을 검사했는데, 세마포어 값이 0이라면 사용할 수 있게 될 때까지(즉, 1이 될 때까지) 기다림(block)

* 교착 상태(deadlock)
    * 교착 상태
        * 둘 이상의 프로세스들이 서로 다른 프로세스가 차지하고 있는 자원을 요구하며 무한정 기다리게 되어, 결국 해당 프로세스들의 진행이 중단되는 현상
    * 교착 상태의 방지
        * 프로세스가 수행 도중에 필요로 하는 모든 자원을 미리 한꺼번에 배당함
        * 자원이 배당되는 순서를 미리 정하여, 교착 사앹의 특징인 프로세스들의 순환적 대기(circular waiting)현상을 방지함
        * 프로세스가 필요로 하는 자원의 최대량을 미리 선언하도록 하여 자원 사용에 제한을 두는 방법임
        * 자원을 무한정 기다리는 것을 방지하기 위해 일정 시간이 지나면 무조건 그 프로세스의 실행을 중지시켜 배당했떤 자원 모두를 회수하고, 다음 처리 순서 때 다시 배당하는 방안임
        * 교착 상태가 발생할 경우 그 회복(recovery)은 상당히 어려운 문제임
            * 일단 우선 순위가 낮은 교착 상태의 프로세스를 강제 종료시킨 후, 그 프로세스가 점유했던 자원을 회수함으로써 시스템을 안전한 상태로 복구하는 방법이 있음

## 리눅스 프로세스 관리
* 리눅스
    * 멀티프로세싱 운영체제로서 개별 프로세스는 자신의 가장 주소강간에서 실행됨
* 멀티프로세싱의 목적
    * 각각의 CPU가 언제나 실행 중인 프로세스를 갖도록 하여 CPU의 활용을 극대화 하는 것임
    * DOS와 같은 유니프로세싱(uniprocessing) 시스템에서는 프로세스가 CPU를 사용하고 있지 않을 때, 즉 입,출력 작업을 하는 동안에, CPU는 아무 것도 하지 않고 시간을 낭비함
* 멀티프로세싱 시스템에서는 동시에 많은 프로세스들이 메모리 내에 존재함
* CPU를 사용하고 있던 프로세스가 CPU를 사용하지 않고 기다리게 될 때마다 운영체제는 CPU를 빼앗아서 다른 적당한 프로세스가 사용하도록 함
* 어떤 프로세스가 다음에 실행될 가장 적당한 것인지 스케줄러가 결정하는 데, 리눅스는 공정을 기하기 위해 여러가지의 그케줄링 정책을 사용함
* 리눅스의 특징
    * 커널이 제공하는 안전한 방법을 통하지 않고서는 다른 프로세스와 상호작용 할 수 없음
* 리눅스의 각각의 프로세스는 task_struct라는 자료구조로 표현됨
* 리눅스에서는 task와 process는 같은 의미로 사용됨
* task 벡터 - 시스템에 있는 task_struct 구조로 가리키는 포인드들의 배열
* 시스템이 가질 수 있는 프로세스의 수가 task 벡터의 크기로 제한됨(기본값이 512개임)
* 프로세스가 만들어지면 시스템 메모리에서 새로운 task)struct가 할당되어 task 벡터에 추가됨
* 현재 실행되고 있는 프로세스를 찾기 쉬베 하기 위해서, 이를 current 포인터가 가리키고 있음
* 프로세스는 프로세스 식별자를 가짐
* 최초의 프로세스를 제외하고 부모 프로세스를 가짐
    *  새로운 프로세스는 생성되는 것이 아니라 이전의 프로세스로부터 복사(copy) 또는 복제(clone)이 됨
* task_struct는 다음과 같은 포인터를 가지고 있음
    * 부모 프로세스, 형제(sibling, 부모가 같은 프로세스들) 프로세스, 자신의 자식(child) 프로세스
 

![image](https://user-images.githubusercontent.com/76929823/120910531-a63a7e00-c6ba-11eb-84d1-f53f136e6935.png)


 ## 프로세서 관리
* 작업 스케줄링(job scheduling)
    * 다음의 입력 작업을 선정함
        * 일괄 처리 시스템 - 작업 스케줄러(job scheduler)
        * 시분할 시스템 - 명령 인터프리너(command interpreter)
* 작업 스케줄러
    * 입력작업으로 형성된 작업 대기여(job queue)을 조사하여 실행 가능한 다음 작업을 선정하는 제어 프로세스
    * 새로운 작업을 받아들이고 해당 프로세스를 생성함
    * 입력되는 작업 수의 조정 기능과 함께 입력된 작업 중 우선적으로 실행할 작업을 결정함
        * 스케줄링 정책(scheduling polity)

* 프로세스 스케줄링(process cheduling)
    * 다음에 수행될 프로세스를 선정함
        * 프로세스 스케줄러, 디스페처(dispatcher): 준비 리스트에서 다음 수행될 프로세스를 결정함
       ![image](https://user-images.githubusercontent.com/76929823/120910526-a2a6f700-c6ba-11eb-9322-4a8ea92d1117.png)


* 스케줄링 정책 - 스케줄러에 포함된 일련의 선정 규칙
* 작업 스케줄링 정책 - 다음의 입력 작업을 선정하기 위한 규칙
* 프로세스 스케줄링 정책 - 다음에 수행될 프로세스 선정에 관한 규칙
![image](https://user-images.githubusercontent.com/76929823/120910546-b5b9c700-c6ba-11eb-835c-615e441f543b.png)

## 기억 장치의 관리
* 기억장소 할당(memory allocation)
    * 수행 대상의 작업에게 주기억장치의 공간을 배정함
    * 고정된 분할(fixed partiton)
        * 기억장소를 고정된 연속 영여들로 분할(partition)하여 여러 작업에 각각의 분할 영역을 배정함
        * 작업의 크기가 고정된 분할 영역의 크기보다 크면 사용이 불가능하여 기억장소낭비를 초래함
    * 동적 기억장소 할당(dynamic memory allocaiton)
        * 각 작업과 ㄱ윻사한 크기로 분할된 가변 분할(variable partition)영역을 작업에 배정함
        * 주기억장소의 단편화(fragmentation) 문제가 발생함
* 교체(swapping)
    * 시분할 시스켐에서 주로 사용함
    * 한 작업이 프로세서에 의해 수행되지 않고 입출력 동작 중일 때, 이 작업을 주기억장치로부터 보조기억장치로 내보내고 우선순위가 높은 그 다음 작업으로 대체함
    * 교체시간(swapping time)
        * 해당 작업을 보조기억장치로부터 주기억장치로 교체하거나 또는 그 역순으로 고체하는 데 소요되는 시간

* 오버레이(overlay)
    * 작업 수행에 요구되는 총 기억장치의 용량이 사용 가능한 주기억장치의 용량을 초과할 때 사용함

* 세그멘테이션(segentation)
    * 어느 순간의 필요한 작업의 일부만을 주기억장치 내에 있도록 운영체제가 프로그램을 부분적으로 나누어 실행하는 기법
    * 주소지정 -> 세그멘트 번호와 해당 세그먼트 내의 오프셋(offset)의 조합
    * 주기억장치 내에 없는 세그마ㅓㄴ트를 접근하면 세그먼트 폴트(segment fault)가 발생되고 운영체제에 의해 해당세그먼트를 보조기억장치로부터 주기억장치에 옮겨 옴
    * 사용 중인 세그먼트만이 주기억장치 내에 있으므로 고체 및 오버레이가 자동적으로 해결되지만, 주기억장치의 단편화(fragmentaiton) 발생함

* 페이징(paging)
    * 다수의 병행적으로 샐행되는 프로그램들 간에 제한된 양의 주기억장치를 비연속적으로 관리함
    * 페이지(page): 물리적 단위로 프로그램을 분할한 고정 크기
    * 프로세서가 생성하는 노리적 주소(페이지 번호와 페이지 오프셋으로 구성됨)
        * 페이지 테이블(각 페이지 기준주소(base address)를 보관함)을 사용하여 기억장치의 실제 주소로 변환함

* 가상기억장치(virtual memory)
    * 사용자로 하여금 보조기억장치(디스크)를 주기억장치(RAM)의 확장으로 간주하게 하여 기억용량의 제한이 없도록 하는 기법

## 리눅스의 메모리 관리
* 리눅스는 가상 기억장치(virtual memory)를 지원함
    * 스왑영역(swap 영역) - 가상 메모리로 쓰이는 하드디스크의 영역
    * 스왑영역으로 일반적인 파일을 사용할 수도 있고 별도의 스왑을 위한 파티션을 사용할 수도 있음
      ![image](https://user-images.githubusercontent.com/76929823/120910902-abe59300-c6bd-11eb-9187-811ce81ccd4b.png)
    * 여러 개의 스왑 파티션과 스왑 파일을 섞어서 사용할 수 있음
        * 언제나 큰 용량의 스왑 영역을 잡을 필요없이 그때 그때 필요한 만큼만 스왑을 늘려줄 수 있으므로 편리함

* 스왑 파일 생성
    * 아무 섹터도 할당되지 않은 공간인 빈틈(holes)이 없어야 함
    ```linux
    $dd if = /dev/zero of=/extra-swap bs = 1024 count = 1024
             1024+0 records in
             1024+0 records out
             $
    ```
   ![image](https://user-images.githubusercontent.com/76929823/120911008-7ab99280-c6be-11eb-9d00-9b3c134b8c07.png)
    
    * 스왑 파티션 생성
        * 다음 사항을 제외하고는 다른 파티션과 동일함
            * 스왑 파티션에는 어떤 파일시스템도 사용되지 않으며, 본래의 파티션(raw partition)을 그대로 사용함
            * 스왑용으로 쓸 파티션은 type 82로 지정해 두는 것이 좋음 -> 파티션의 용도가 명확해짐
   
   ![image](https://user-images.githubusercontent.com/76929823/120911011-8311cd80-c6be-11eb-81b6-090f2e86a3f8.png)

## 리눅스 프로세스 동기화 프로그래밍
### sem_init
* 세마포어는 아음과 같이 선언된 sem_init 함수를 통해 생성됨
```linux
#include <semaphore.h
 int sem_init(sem_t *sem, int pshared, unsigned int value);
```
* sem이 가리키는 세마포어 오브젝트를 초기화하고 공유 옵션을 설정하여 초기 저수값을 줌
* pshared 파라미터는 세마포어의 형태를 제어함
    * pshared의 값이 0이면, 세마포어는 현재 프로세스에 지역적임
    * 그렇지 않으면, 세마포어는 프로세스간에 공유될 수 있음
### sem_post, sem_wait
